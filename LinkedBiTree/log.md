# 概述
- 二叉树的元素`elem`中有**主值**`int key`和**数据**`char others[]`
- 用`DATA_LEN`宏表示数据的最大长度
- 树结点中有**数据域**`elem data`和**指针域**`lChild, rChild`
- key==0时表示该元素所在结点为空结点。
- 根节点数据域为0和指针域都为`NULL`时表示树为空
- 动态管理多树，可以把一棵树添加为另一棵树的子树
- 一棵树有树名和树根，树根为NULL时树不存在
# 额外基本操作
### 直接打印
### 删除结点
### 据key查找结点
### key查重
- 建立一个存储所有key的链表，以0结尾
- 若新建结点，则在链表中查找是否有重复key
    - 若有则提示重复
    - 若无则可以新建结点，并把key加入链表
### 存储待创建结点列表
- 用结点的指针的指针存储结点的指针
- 接收输入
- key查重
- 加入列表
- 确认是否继续添加
# 基本操作
### 前序遍历
- 先对结点执行visit，不使用visit的返回值
- 然后对左右子遍历，并给level的值+1
- 按层输出(BiTree, int)、前序输出(BiTree)需要用到。
### 中序遍历
- 先对左子遍历
- 若value指针不为空，则value指针值为visit的返回值
- 再对右子遍历
- 中序输出(BiTree)、查找结点(BiTree, int)、左右兄弟(BiTree, int)、查找双亲(BiTree, int)要用到
### 后序遍历
- 先对左右子遍历
- 再visit当前结点，不使用visit的返回值
### 创建二叉树
- 用传入的先序遍历结点序列创建
- 创建过程：（i遍历序列，j遍历栈）
  - 把一个结点入栈,j++
  - 上个结点无左孩子则该结点是左孩子，
  - 上个结点有左无右则该结点是右孩子，
  - 上个结点叶子已满则j-=2
  - 若结点为空则j--
### 层序遍历
- 每到新一层建立一个孩子层栈，同时之前的双亲栈作废
- 为节省内存，栈中放指针就行了
- 上一层时的孩子栈变为现在的双亲栈
- 开始遍历双亲栈的孩子
- 每遍历一个就把一个放入孩子栈，空结点不入栈
- 为节省空间，可以每遍历过双亲的右孩子就把该双亲退栈（好像不行）
### 树形打印
- 以先序遍历为基础，可以不打印空结点
### 求深度
- 在遍历中调用求深度函数，传入初始*level=1
- 每到左右子时level+1，左右子均为空尝试写入level
- 若待写入的level比已有的大则覆盖，小则什么也不做
### 取值
- 调用遍历，在遍历中调用比较函数
- 若与主值相等则遍历返回结点地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值
- 在取值函数中读取返回指针的值并返回
### 获取双亲指针
- 输入树T和主值key，返回双亲的指针
- 在遍历中调用获取双亲函数
- 若结点的左右子中有e则该结点为e的双亲，返回该结点的地址
### 获取左子指针
- 输入主值key
- 调用遍历，在遍历中调用比较函数
- 若与主值相等则遍历返回结点地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值
- 在获取左子指针中取左子指针即可
### 获取右子指针
- 遍历至该结点取右子即可
### 获取左兄弟指针
- 输入主值key
- 调用遍历，在遍历中调用取左兄弟函数
- 若右子与主值相等则遍历返回左子地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值
### 获取右兄弟指针
- 输入主值key
- 调用遍历，在遍历中调用取右兄弟函数
- 若左子与主值相等则遍历返回右子地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值
### 插入子树
- 输入被插入结点主值key，插入子树根结点（右子为NULL），插入左右
- 调用遍历，在遍历中调用比较函数
- 若与主值相等则遍历返回结点地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值
- 把返回结点的左/右子指针备份，插入子树后把备份指针设为子树右子
### 赋值
- 输入主值key和data 
- 调用遍历，在遍历中调用比较函数
- 若与主值相等则遍历返回结点地址，否则返回NULL
- 若遍历返回不为空则返回上层遍历的返回值